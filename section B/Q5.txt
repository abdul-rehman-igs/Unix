Q5: Consider the given code snippet answer the following questions

a) If two threads execute the same function concurrently, what will be the final value of
shared_resource? Explain the issue related to accessing a shared variable/resource in this
scenario.
b) How can mutual exclusion be enforced to protect the shared resource shared_resource?
Modify the incrementer function to demonstrate the required code changes.

void incremneter(void arg) {
for (int i =0; i < 2000000; i++) {
shared_resource++;
}
}

Answer:

a) The final value of shared_resource is unpredictable and usually less than 4,000,000 due to race condition caused by unsynchronized access.

b) 
#include <pthread.h>

extern int shared_resource;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void* incrementer(void* arg) {

    for (int i = 0; i < 2000000; i++) {

        // Lock before accessing shared resource
        pthread_mutex_lock(&lock);

        shared_resource++;

        // Unlock after access
        pthread_mutex_unlock(&lock);
    }

    return NULL;
}